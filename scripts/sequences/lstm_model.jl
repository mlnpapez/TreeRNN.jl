#=
###############################################
#                                             #
#          LSTM Model Implementation          #
#                                             #
#                                             #
###############################################

This file implements a Long Short-Term Memory (LSTM) model
for sequence (next character) prediction based on the dataset generated by ALICE.

Author: Do Viet Anh
=#

using Flux
using LinearAlgebra

# Define the LSTM cell structure
struct LSTMCell{T}
    w::Matrix{T}  # Input weights
    u::Matrix{T}  # Hidden weights
    b::Vector{T}   # Bias
end

Flux.@functor LSTMCell

"""
Initialize an LSTM cell wth given input and hidden sizes
"""
function LSTMCell(input_size::Int, hidden_size::Int; init=Flux.glorot_uniform)
    return LSTMCell(
        init(4 * hidden_size, input_size),
        init(4 * hidden_size, hidden_size),
        init(4 * hidden_size)
    )
end

"""
Forward pass for the LSTM cell
"""
function (m::LSTMCell)(h::Tuple{AbstractVector, AbstractVector}, x::AbstractVector)
    h, c = h
    gates = m.w * x .+ m.u * h .+ m.b
    input, forget, cell, output = Flux.chunk(gates, 4)  # This splits into 4 parts
    
    input = σ.(input)
    forget = σ.(forget)
    cell = tanh.(cell)
    output = σ.(output)
    
    c = forget .* c .+ input .* cell
    h = output .* tanh.(c)
    
    return (h, c), h
end

# Define the full LSTM model structure
mutable struct LSTM
    cell::LSTMCell
    output::Chain
    state::Vector{Float32}  # Combined h and c
end

Flux.@functor LSTM

"""
Initialize the full LSTM model
"""
function LSTM(input_size::Int, hidden_size::Int, output_size::Int)
    return LSTM(
        LSTMCell(input_size, hidden_size),
        Chain(Dense(hidden_size, output_size), softmax),
        zeros(Float32, 2 * hidden_size)  # Combined h and c
    )
end

"""
Forward pass for the full LSTM model
"""
function (m::LSTM)(x::AbstractMatrix)
    hidden_size = div(length(m.state), 2)  # Calculate hidden size
    outputs = map(1:size(x,2)) do t
        h = m.state[1:hidden_size]         # First half is h
        c = m.state[hidden_size+1:end]     # Second half is c
        (new_h, new_c), h_out = m.cell((h, c), x[:, t])
        m.state = vcat(new_h, new_c)
        m.output(h_out)
    end
    return hcat(outputs...)
end

"""
Reset the LSTM model's state
"""
function Flux.reset!(m::LSTM)
    m.state = zeros(Float32, length(m.state))
end